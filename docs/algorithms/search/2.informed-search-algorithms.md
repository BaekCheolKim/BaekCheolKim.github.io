---
layout: default
title: Informed Search Algorithms
parent: Search
grand_parent: Algorithm
nav_order: 2
---

# Informed Search Algorithms

informed is hueristic

# Evaluation function
Formula: ğ‘“(ğ‘›)=g(n)+h(n)
â€¢ g(n): Cost so far to reach node ğ‘›.
â€¢ h(n): Estimated cost from ğ‘› to the closest goal (heuristic).
â€¢ f(n): Estimated total cost of the path through ğ‘› to the goal.

so, lower ğ‘“(ğ‘›) indicates more desirable node. 
and Frontier is a queue sorted in ascending value of ğ‘“(ğ‘›)

special cases: 
(link) Uniform Cost Search (Uninformed): ğ‘“(ğ‘›)=ğ‘”(ğ‘›)
(link) greedy search (informed) : ğ‘“(ğ‘›)=â„(ğ‘›)
(link) A* search (informed) : ğ‘“(ğ‘›) = ğ‘”(ğ‘›) + â„(ğ‘›)
link the iamge a graph that has heuristics in a node and cost on arcs
assets\images\search\graph-heuristic&cost.jpg

# admissibility
A heuristics is admissible when the estimated cost must always be lower than or equal to the actual cost of reaching the goal state.
A heuristic is admissible if it never overestimates the cost to reach the goal from any node.

for example,
(assets\images\search\admssibility.jpg)
Heuristic I:
h(A) = 4 â‰¤ 5 (cost from A to G through B)
h(B) = 1 â‰¤ 3 (cost from B to G)
h(G) = 0 = 0 (cost from G to G)
Admissible.

Heuristic II:

h(A) = 6 > 5 (cost from A to G through B)
h(B) = 3 â‰¤ 3 (cost from B to G)
h(G) = 0 = 0 (cost from G to G)
Not Admissible because it overestimates the cost from A
# consistency
A heuristic is consistent, if its estimate is always less than or equal to the estimated distance from any neighbouring vertex to the goal, plus the cost of reaching that neighbour.
A heuristic is consistent if, for every node ğ‘› and its successor ğ‘›â€², the estimated cost from ğ‘› to the goal is no greater than the step cost to ğ‘›â€² plus the estimated cost from ğ‘›â€² to the goal.

A consistent heuristic is also admissible, i.e. it never overestimates the cost of reaching the goal (the converse, however, is not always true)
If a heuristic is not admissible, hence it is Not Consistent by definition

# Greedy search
â€¢ evaluation function is heuristic : ğ‘“(ğ‘›) = â„(ğ‘›) (entirely heuristic).

 It greedly selects and explores the node that has the lowest heuristic value â„(ğ‘›) and chooses what looks like best solution at any given moment; its choice is â€œlocalâ€ and does not depend on solution to subproblems so it may or may not be globally optimal but it always produces a feasible solution by definition but could be stuck in a loop. Also it may not find a solution if the search space is infinite and the heuristic is misleading.

# A* Search
â€¢ Evaluation Function: ğ‘“(ğ‘›)=ğ‘”(ğ‘›)+â„(ğ‘›)
â€¢ data structure : priority queue
â€¢ admissibility : When â„(ğ‘›) is admissible; âˆ€ğ‘› â„(ğ‘›) â‰¤ â„*(ğ‘›), ğ‘“(ğ‘›) never overestimates the total cost of the optimal path through ğ‘› to the goal; optimal
â€¢ consistency : A heuristic is consistent if for every node ğ‘› and its successor ğ‘›â€², the estimated cost to reach the goal from ğ‘› is no greater than the cost of getting from ğ‘› to ğ‘›â€² plus the estimated cost from ğ‘›â€² to the goal; â„(ğ‘›) â‰¤ ğ‘(ğ‘›,ğ‘›â€²)+â„(ğ‘›â€²) Where ğ‘(ğ‘›,ğ‘›â€²) is the cost of the edge from ğ‘› to ğ‘›â€². So, consistency ensures that A* will not need to revisit nodes and will find the optimal path efficiently.

â€¢ Properties of A Search*
Completeness: A* is complete, meaning it will find a solution if one exists, given that the branching factor is finite and each step costs at least some small positive constant.
Optimality: A* is optimal if the heuristic is admissible and consistent.
Time and Space Complexity: The time and space complexity of A* is exponential in the worst case but can be mitigated with good heuristics.

pseudocode:
   make an openlist containing only the starting node
   make an empty closed list
   while (the destination node has not been reached):
       consider the node with the lowest f score in the open list
       if (this node is our destination node) :
           we are finished 
       if not:
           put the current node in the closed list and look at all of its neighbors
           for (each neighbor of the current node):
               if (neighbor has lower g value than current and is in the closed list) :
                   replace the neighbor with the new, lower, g value 
                   current node is now the neighbor's parent            
               else if (current g value is lower and this neighbor is in the open list ) :
                   replace the neighbor with the new, lower, g value 
                   change the neighbor's parent to our current node

               else if this neighbor is not in both lists:
                   add it to the open list and set its g

# Dijkstra's algorithm
As another example of a uniform-cost search algorithm. If â„(ğ‘›) = 0, A* becomes Dijkstra's algorithm, which is guaranteed to find a shortest path.